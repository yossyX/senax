# キャッシュ

## エンティティキャッシュ
テーブルのデータとリレーション先のデータをまとめてキャッシュします。
リレーション先は1世代のみです。

## ショートキャッシュ
insertされたデータが必ずしも参照されるとは限らないので、参照されるまでTTLの短いショートキャッシュに保存されます。

## 高速キャッシュ
エンティティキャッシュをノンブロッキングでより高速に参照できるキャッシュです。  
キャッシュのみのベンチマークでは高速ですが、全体としての影響は未確認です。  

## ディスクキャッシュ
キャッシュをディスクに保存します。保存先はSSDを想定しています。  
io_uringを使用しているため、Linuxのみ対応。  
ディスクキャッシュに保存されている位置を示すインデックス領域をメモリ上に必要とするため、大容量のディスクキャッシュは難しいかもしれません。  
ホットデプロイではディスクキャッシュの再利用を行わず、別ファイルとなります。瞬時にディスクキャッシュがフルになって2倍の容量を必要とすることはないと思われますが、前のサーバが速やかに終了しない場合問題が発生する可能性があります。  
単純な追記書き込みのため、容量効率はよくありませんが、下記2点に特化しています。

* ディスクキャッシュ上に保存されているかの判定がメモリ上で瞬時に可能
* 指定されたディスク容量を絶対にオーバーしない

## バージョンキャッシュ
キャッシュの更新とDBからの取得がほぼ同時の場合に不整合が発生していないかの確認のため、バージョン機能を有効にしている場合にバージョンナンバーをキャッシュします。

## ユニークインデックスキャッシュ
ユニークインデックスがある場合、ユニークインデックスからIDを検索するためのユニークインデックスキャッシュを使用します。

## ダミーキャッシュ
「いいね！」などの表示は押されていなければデータが無いのでキャッシュされず、何度も再取得されることになる。  
その場合、「いいね！」を解除した状態のデータを insert_dummy_cache で登録することで代わりのキャッシュとすることができる。

## サーバ間同期
サーバ間の同期は全データを送るのではなく、更新されたカラムのデータのみ送信します。
受信側はキャッシュを保有していれば受信した更新内容でキャッシュを更新します。
ですので、同時に異なったサーバで更新されてもそれが異なるカラムであれば問題ありません。  
同じカラムが更新される場合は、add()やmax()などのメソッドで更新していれば、それぞれ加算や現在値と更新値の最大値での更新になりますので、問題が発生しにくくなります。  
更にバージョン機能を有効にすれば同期が確実になります。

## キャッシュ更新通知
_receive_update_notice() で他のサーバからのキャッシュ更新通知を受信して処理をカスタマイズすることができます。新着やランキングの修正、チャット通知などに利用できます。 

## マイクロサービス化
サービスを再起動するとキャッシュは破棄されます。
新規のイベントの実装等で既存の安定したサービスのキャッシュが破棄されないようにマイクロサービスアーキテクチャで実装することが望ましいです。
その場合、必ずしも相互のリモートAPIを呼び出す必要はなく、データの参照程度であればローカルのメソッドを呼び出してデータを取得し、更新はキャッシュ更新通知で受信することができるので、実装が簡単で高速です。