# キャッシュ

## エンティティキャッシュ
SenaXは一般的なORMのようなクエリーキャッシュの動作はせず、エンティティキャッシュを基本にテーブルのデータとリレーション先のデータをまとめてキャッシュします。
リレーション先は1世代のみです。

## ショートキャッシュ
insertされたデータが必ずしも参照されるとは限らないので、参照されるまで比較的TTLの短いショートキャッシュに保存されます。

## 高速キャッシュ (FAST_CACHE)
エンティティキャッシュをノンブロッキングでより高速に参照できるキャッシュです。  
非常に高いキャッシュヒット率の環境下での速度安定化に貢献します。  

## ディスクキャッシュ
キャッシュをディスクに保存します。保存先はSSDを想定しています。  
io_uringを使用しているため、Linuxのみ対応しています。  
ディスクキャッシュに保存されている位置を示すインデックス領域をメモリ上に必要とします。そのため、大容量のディスクキャッシュは難しいかもしれません。  
ホットデプロイの場合でもディスクキャッシュの再利用を行わず、別ファイルとなります。
瞬時にディスクキャッシュがフルになって2倍の容量を必要とすることはないと思われますが、前のサーバが速やかに終了しない場合は問題が発生する可能性があります。  
単純な追記書き込みのため、容量効率はよくありませんが、下記2点に特化しています。

* ディスクキャッシュ上に保存されているかの判定がメモリ上で瞬時に可能
* 指定されたディスク容量を絶対にオーバーしない

## バージョンキャッシュ
キャッシュの更新とDBからの取得がほぼ同時の場合に不整合が発生していないかの確認のため、バージョン機能を有効にしている場合にバージョンナンバーをキャッシュします。

## ユニークインデックスキャッシュ
ユニークインデックスがある場合、ユニークインデックスからIDを検索するためのユニークインデックスキャッシュを使用します。

## ダミーキャッシュ
「いいね！」などの表示は押されていなければデータがありませんのでキャッシュされず、何度も再取得されることになります。  
その場合、「いいね！」を解除した状態のデータを insert_dummy_cache で登録することで代わりのキャッシュとすることができます。

## サーバ間同期
サーバ間の同期は全データを送るのではなく、更新されたフィールドのデータのみ送信します。
受信側はキャッシュを保有していれば受信した更新内容でキャッシュを更新します。
ですので、同時に異なったサーバで更新されてもそれが異なるフィールドであれば問題ありません。  
同じフィールドが更新される場合は、add()やmax()などのメソッドで更新していれば、それぞれ加算や現在値と更新値の最大値での更新になりますので、問題が発生しにくくなります。  
さらにバージョン機能を有効にすれば同期が確実になります。

## キャッシュ更新通知
_receive_update_notice() で他のサーバからのキャッシュ更新通知を受信して処理をカスタマイズすることができます。独自に実装した新着やランキングの修正、チャット通知などに利用できます。 

## マイクロサービス化
サービスを再起動するとキャッシュは破棄されます。
新規のイベントの実装等により、既存の安定したサービスのキャッシュが破棄されないようにマイクロサービスアーキテクチャで実装することが望ましいです。
その場合、必ずしも相互のリモートAPIを呼び出す必要はなく、データの参照程度であればローカルのメソッドを呼び出してデータを取得すれば、更新はキャッシュ更新通知で受信することができるので実装が簡単で高速です。