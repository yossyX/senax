# SenaXについて

SenaXはRustで書かれたORMで、キャッシュに特化しており非常に高速に動作します。  
非常に高速に動作し、具体的な速度例として、DBからの取得とカウンター加算の更新を行うAPIのリクエストを100%キャッシュヒットであれば32vCPUで42万req/s程度の性能を出すことができます。  

他の一般的なORMのキャッシュではそのサーバ単体でのキャッシュでしかなく、他のサーバでデータが更新された場合の同期は自動的には行われないことがほとんどです。
SenaXはクエリーの更新内容を他のサーバに送信し、自動的にキャッシュを同期します。

SenaXはyaml形式のスキーマからDBレイヤーのソースコードとマイグレーションDDLを自動生成します。
マクロ生成やライブラリを使用するORMでは挙動の理解や部分的な修正が困難ですが、SenaXで生成されたコードは比較的単純で理解しやすく、コピーしてカスタマイズすることも可能です。

SenaXの特徴として次の点が挙げられます
* 取得クエリー集約
* エンティティキャッシュ
* 遅延一括更新
* サーバ間キャッシュ更新同期

### 取得クエリー集約
一般的なORMではAPIへのアクセスごとにそれぞれDBへクエリーを送り、その結果を返します。  
SenaXではほぼ同時に行われたアクセスからのDBへのクエリーを一つにまとめ、一回のクエリーで結果を取得します。  
具体的には主キーでの取得をINクエリーに変換して取得します。

これにより、キャッシュにないデータにアクセスが殺到した場合のDBの負荷を低減します。

### エンティティキャッシュ
エンティティのリレーションのデータは取得時のJOINクエリーに依存して取得するのではなく、スキーマに定義されたone-to-oneあるいはone-to-manyの下位の結合関係を持つテーブルのデータを常にまとめてキャッシュします。
キャッシュの取得が主キーからのみでは従属側のテーブルから外部キーでの複数行取得ができませんので、まとめてキャッシュすることによってリレーションのデータ取得を改善できます。  
また、エンティティの取得はユニークキーからの取得も対応しています。

### 遅延一括更新
ログなどをDBに保存する際に、同時に受け付けた他のアクセスのログとまとめてバルクインサートで保存することができます。  
また、同一ページへのアクセスカウンタなどは同時にアクセスしたカウントアップ数をまとめて、合計数でのDB更新にも対応しています。

### サーバ間キャッシュ更新同期
キャッシュに保存されたデータが更新される場合、他のサーバにも更新内容を伝達してそれぞれのサーバのキャッシュが最新であるように同期されます。  
更新差分はフィールドごとに処理されるため、別のサーバで同時に異なるフィールドが更新されても問題ありません。
同じフィールドが更新される場合はバージョン管理で競合を防ぐことができます。