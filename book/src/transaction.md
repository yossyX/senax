# トランザクション分離レベル

MySQL や PostgreSQL などのデータベースは、MVCC（Multi-Version Concurrency Control）をサポートしており、一方ではすべてのテーブルに対して同時に取得したスナップショットを読み取りながら、同時に他方ではロックされることなく更新が可能である。ただ、これらを一つのトランザクション分離レベルで混在して扱うと様々な問題や長時間のロックが発生する。
例として長時間かかる集計バッチと、激しい更新競合が発生するケースについて考える。
集計バッチで集計元のテーブルと集計結果を書き込むテーブルがあった場合、一般的に集計元のテーブルは集計バッチでの処理は参照のみであるがバッチ実行中にも他からデータの登録を受け付ける可能性が高く、集計結果テーブルに書き込むのは集計バッチのみで他と競合する可能性は低い。このようなケースで集計のトランザクションと集計結果を書き込むトランザクションのトランザクション分離レベルを分けることにより、集計元のテーブルはデータの更新を随時受け付けながら集計バッチ内ではバッチ開始時のスナップショットを維持して参照可能となる。
また、激しい更新競合が発生するケースについてはMySQLのデフォルトのトランザクション分離レベルでは INSERT IGNORE で登録したデータを読み込もうとしても、同時に処理が行われた場合に一方では他方がcommitした後でも書き込んだデータが読み込めないなどの問題が発生する。他にもギャップロックによるデッドロックなどの問題も発生する。これらは更新用トランザクションをデフォルトの REPEATABLE READ から READ COMMITTED に変更することにより解決する。PostgreSQLでは、READ COMMITTED がデフォルトになっていることからも、READ COMMITTED への変更は問題ないと考えられる。
よって、SenaXでは更新用トランザクションと参照用トランザクションにわけ、それぞれ READ COMMITTED と REPEATABLE READ のトランザクション分離レベルを適用することによりこれらの問題を解決している。


更新用トランザクションと参照用トランザクションを一つの処理内で同時に使用する場合、更新用と参照用の取得順序が混在しているとコネクションプールからの取得がデッドロックする可能性がありますので、取得順序を統一する必要があります。  
また、キャッシュの取得は現在使用しているコネクションとは別コネクションで参照用トランザクションを用いて取得されます。  

## 更新用トランザクション

```rust
let mut conn = DbConn::new();
conn.begin().await?;

conn.commit().await?;
```

## 参照用トランザクション

```rust
let mut conn = DbConn::new();
conn.begin_read_tx().await?;
```

## セーブポイント

更新用トランザクションがネストされているとセーブポイントになります。

## トランザクションを使用しない場合
意図的にトランザクションを使用していないのか、あるいは実装漏れなのか分からないのはバグの元です。
そのため、トランザクションを使用しない自動コミットの場合は begin_without_transaction() の呼び出しが必要です。  
単純なinsert, updateが可能です。クエリーの実行ごとにコネクションが変わっている可能性がありますので、DB接続のセッションの連続性に依存する処理はできません。  
また、force_delete では更新用トランザクションが必要です。

```rust
let mut conn = DbConn::new();
conn.begin_without_transaction().await?;
```

