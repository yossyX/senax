// This code is automatically generated by Senax and is always overwritten.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unreachable_patterns)]

use ::anyhow::Result;
use ::fxhash::FxHashMap;
use ::indexmap::IndexMap;
use ::schemars::JsonSchema;
use ::senax_common::{cache::msec::MSec, ShardId};
use ::serde::{Deserialize, Serialize};
use ::std::path::Path;
use ::std::sync::Arc;
use ::std::time::Duration;

use db::{models::@{ group_name|snake|ident }@::CacheOp, DbConn, DELAYED_DB_DIR};

#[rustfmt::skip]
#[allow(clippy::map_identity)]
#[allow(clippy::match_single_binding)]
#[allow(clippy::clone_on_copy)]
#[allow(clippy::nonminimal_bool)]
#[allow(clippy::useless_conversion)]
#[allow(clippy::enum_variant_names)]
#[allow(clippy::collapsible_if)]
#[allow(clippy::assigning_clones)]
#[allow(clippy::too_many_arguments)]
@%- if SEPARATED_BASE_FILES %@
pub mod _base {
@%- for name in mod_names %@
    pub mod _@{ name }@;
@%- endfor %@

@%- for (u, m) in unified_names %@
    pub use _base_repo_@{ db|snake }@_@{ u }@::repositories::@{ group_name|snake|ident }@::_base::_@{ m }@;
@%- endfor %@
}
@%- else %@
pub mod _base;
@%- endif %@

#[rustfmt::skip]
pub async fn start(db_dir: Option<&Path>) -> Result<()> {
@%- for (name, def) in models %@
    _base::_@{ def.mod_name() }@::init().await?;
@%- endfor %@

    if !db::is_test_mode() {
        let path = db_dir.unwrap().join(DELAYED_DB_DIR).join("@{ group_name }@");
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(2)).await;
                let db = sled::open(&path);
                match db {
                    Ok(db) => {
                        @%- for (name, def) in models %@
                        _base::_@{ def.mod_name() }@::init_db(&db).await.unwrap();
                        @%- endfor %@
                        break;
                    }
                    Err(e) => ::log::error!("{}", e),
                }
            }
        });
    }
    Ok(())
}

pub async fn check(shard_id: ShardId) -> Result<()> {
    @%- for (name, def) in models %@
    @%- if !def.skip_ddl %@
    _base::_@{ def.mod_name() }@::check(shard_id).await?;
    @%- endif %@
    @%- endfor %@
    Ok(())
}

#[rustfmt::skip]
impl super::GroupCacheOpTr for CacheOp {
    #[allow(unreachable_patterns)]
    #[allow(clippy::single_match)]
    async fn handle_cache_msg(self, _sync_map: Arc<FxHashMap<ShardId, u64>>) {
        @%- if !config.force_disable_cache %@
        use super::CacheOpTr as _;

        match self {
@%- for (name, def) in models %@
            CacheOp::@{ name|to_pascal_name }@(msg) => msg.handle_cache_msg(_sync_map).await,
@%- endfor %@
            _ => {},
        };
        @%- endif %@
    }
}

#[rustfmt::skip]
pub async fn _clear_cache(_shard_id: ShardId, _sync: u64, _clear_test: bool) {
@%- if !config.force_disable_cache %@
@%- for (name, def) in models %@
    _base::_@{ def.mod_name() }@::__clear_cache(_shard_id, _sync, _clear_test).await;
@%- endfor %@
@%- endif %@
}

#[rustfmt::skip]
#[allow(clippy::single_match)]
#[allow(clippy::match_single_binding)]
pub async fn seed(seed: &serde_yaml::Value, conns: &mut [DbConn]) -> Result<()> {
    if let Some(mapping) = seed.as_mapping() {
        for (name, value) in mapping {
            match name.as_str() {
@%- for (name, def) in models %@
                Some("@{ name }@") => _base::_@{ def.mod_name() }@::_seed(value, conns).await?,
@%- endfor %@
                _ => {}
            }
        }
    }
    Ok(())
}
@{-"\n"}@