// This code is automatically generated by Senax and is always overwritten.

use ::std::{path::Path, sync::Arc};
use ::ahash::AHashMap;
use ::anyhow::Result;
use ::async_trait::async_trait;
use db::DbConn;
use ::futures::future::BoxFuture;
use ::fxhash::FxHashMap;
use ::senax_common::{cache::msec::MSec, ShardId};
@% for (name, defs) in groups %@
pub mod @{ name|snake|to_var_name }@;
@%- endfor %@

pub(crate) struct Controller;
#[async_trait]
impl db::models::Controller for Controller {
    async fn start(&self, db_dir: &Path) -> Result<()> {
        @%- for (name, defs) in groups %@
        @{ name|snake|to_var_name }@::start(Some(db_dir)).await?;
        @%- endfor %@
        Ok(())
    }
    async fn start_test(&self) -> Result<()> {
        @%- for (name, defs) in groups %@
        @{ name|snake|to_var_name }@::start(None).await?;
        @%- endfor %@
        Ok(())
    }
    async fn check(&self, shard_id: ShardId) -> Result<()> {
        tokio::try_join!(
            @%- for (name, defs) in groups %@
            @{ name|snake|to_var_name }@::check(shard_id),
            @%- endfor %@
        )?;
        Ok(())
    }
    #[cfg(not(feature="cache_update_only"))]
    async fn handle_cache_msg(&self, op: Vec<db::CacheOp>, sync_map: Arc<FxHashMap<ShardId, u64>>) {
        use db::CacheOp;
        for op in op.into_iter() {
            match op {
                @%- for (name, defs) in groups %@
                CacheOp::@{ name|pascal|to_var_name }@(op) => op.handle_cache_msg(Arc::clone(&sync_map)).await,
                @%- endfor %@
                CacheOp::_AllClear => _clear_cache(&sync_map, false).await,
            };
        }
    }
    #[cfg(not(feature="cache_update_only"))]
    async fn _clear_cache(&self, shard_id: ShardId, sync: u64, clear_test: bool) {
        @%- for (name, defs) in groups %@
        @{ name|snake|to_var_name }@::_clear_cache(shard_id, sync, clear_test).await;
        @%- endfor %@
    }
    async fn seed(&self, value: &serde_yaml::Value, conns: &mut [DbConn]) -> Result<()> {
        @%- for (name, defs) in groups %@
        @{ name|snake|to_var_name }@::seed(value, conns).await?;
        @%- endfor %@
        Ok(())
    }
}

pub(crate) async fn _clear_cache(_sync_map: &FxHashMap<ShardId, u64>, clear_test: bool) {
    #[cfg(not(feature = "cache_update_only"))]
    for (shard_id, sync) in _sync_map.iter() {
        if *sync == 0 && !clear_test {
            let shard_id = *shard_id;
            tokio::spawn(async move {
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                @%- for (name, defs) in groups %@
                @{ name|snake|to_var_name }@::_clear_cache(shard_id, 0, clear_test).await;
                @%- endfor %@
            });
        }
        @%- for (name, defs) in groups %@
        @{ name|snake|to_var_name }@::_clear_cache(*shard_id, *sync, clear_test).await;
        @%- endfor %@
    }
}

trait GroupCacheOpTr {
    async fn handle_cache_msg(self, sync_map: Arc<FxHashMap<ShardId, u64>>);
}

#[allow(dead_code)]
trait CacheOpTr<CacheOp, OpData, Data, CacheWrapper, CacheData, PrimaryHasher> {
    fn apply_to_obj(obj: &Option<Arc<CacheWrapper>>, msgs: &[CacheOp], shard_id: ShardId, time: MSec) -> Option<Arc<CacheWrapper>>;
    fn apply_to_list(list: &[Arc<CacheWrapper>], msgs: &[CacheOp], shard_id: ShardId, time: MSec) -> Vec<Arc<CacheWrapper>>;
    async fn update_with_unique_cache(id: &PrimaryHasher, obj: CacheData, update: &Data, op: &OpData, time: MSec) -> CacheData;
    fn handle_cache_msg(self, sync_map: Arc<FxHashMap<ShardId, u64>>) -> BoxFuture<'static, ()>;
}

#[allow(unused_variables)]
pub trait IdTr<Model, Cache, Updater> {
    fn fetch(&self, conn: &mut DbConn) -> impl std::future::Future<Output = Result<Option<Model>>> + Send;
    fn fetch_with_trashed(&self, conn: &mut DbConn) -> impl std::future::Future<Output = Result<Option<Model>>> + Send;
    fn fetch_from_cache(&self, conn: &DbConn) -> impl std::future::Future<Output = Result<Option<Cache>>> + Send;
    fn fetch_from_cache_with_trashed(&self, conn: &DbConn) -> impl std::future::Future<Output = Result<Option<Cache>>> + Send;
    fn fetch_for_update(&self, conn: &mut DbConn) -> impl std::future::Future<Output = Result<Updater>> + Send;
    fn fetch_for_update_with_trashed(&self, conn: &mut DbConn) -> impl std::future::Future<Output = Result<Updater>> + Send;
}

#[allow(unused_variables)]
pub trait CacheTr<Primary, _Self_> {
    fn invalidate_cache<T>(conn: &DbConn, id: T) -> impl std::future::Future<Output = Result<()>> + Send
    where
        T: Into<Primary> + Send;
    fn __push_invalidate_cache_op<T>(conn: &mut DbConn, id: T) -> impl std::future::Future<Output = Result<()>> + Send
    where
        T: Into<Primary> + Send;
    fn __push_notify_cache_op<T>(conn: &mut DbConn, id: T) -> impl std::future::Future<Output = Result<()>> + Send
    where
        T: Into<Primary> + Send;
    fn find_self(&self, conn: &DbConn) -> impl std::future::Future<Output = Result<_Self_>> + Send;
}

#[allow(unused_variables)]
pub trait ModelTr<Primary, Model, Cache, Updater, Filter_, Order_, QueryBuilder> {
    fn find_all_from_cache(
        conn: &DbConn,
        order: Option<Vec<Order_>>,
    ) -> impl std::future::Future<Output = Result<Arc<Vec<Cache>>>> + Send {
        async { unimplemented!("find_all_from_cache is disabled") }
    }
    fn query() -> QueryBuilder;
    fn clear_cache() -> impl std::future::Future<Output = Result<()>> + Send;
    fn find<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Model>> + Send
    where
        T: Into<Primary> + Send;
    fn find_with_trashed<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Model>> + Send
    where
        T: Into<Primary> + Send {
        Self::find(conn, id, filter)
    }
    fn find_from_cache<T>(conn: &DbConn, id: T) -> impl std::future::Future<Output = Result<Cache>> + Send
    where
        T: Into<Primary> + Send {
        async { unimplemented!("find_from_cache is disabled") }
    }
    fn find_from_cache_with_trashed<T>(conn: &DbConn, id: T) -> impl std::future::Future<Output = Result<Cache>> + Send
    where
        T: Into<Primary> + Send {
            Self::find_from_cache(conn, id)
    }
    fn list_to_map(list: Vec<Model>) -> AHashMap<Primary, Model>;
    fn cache_list_to_map(list: Vec<Cache>) -> AHashMap<Primary, Cache>;
    fn updater_list_to_map(list: Vec<Updater>) -> AHashMap<Primary, Updater>;
    fn find_many<I, T>(conn: &mut DbConn, ids: I, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Vec<Model>>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary>;
    fn find_many_with_trashed<I, T>(conn: &mut DbConn, ids: I, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Vec<Model>>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        Self::find_many(conn, ids, filter)
    }
    fn find_many_from_cache<I, T>(conn: &DbConn, ids: I) -> impl std::future::Future<Output = Result<Vec<Cache>>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        async { unimplemented!("find_many_from_cache is disabled") }
    }
    fn find_many_from_cache_with_trashed<I, T>(conn: &DbConn, ids: I) -> impl std::future::Future<Output = Result<Vec<Cache>>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        Self::find_many_from_cache(conn, ids)
    }
    fn find_optional<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Option<Model>>> + Send
    where
        T: Into<Primary> + Send;
    fn exists<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<bool>> + Send
    where
        T: Into<Primary> + Send;
    fn find_optional_for_update<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Option<Updater>>> + Send
    where
        T: Into<Primary> + Send {
        async { unimplemented!("find_optional_for_update is disabled") }
    }
    fn find_optional_with_trashed<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Option<Model>>> + Send
    where
        T: Into<Primary> + Send {
        Self::find_optional(conn, id, filter)
    }
    fn exists_with_trashed<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<bool>> + Send
    where
        T: Into<Primary> + Send {
        Self::exists(conn, id, filter)
    }
    fn find_optional_from_cache<T>(conn: &DbConn, id: T) -> impl std::future::Future<Output = Result<Option<Cache>>> + Send
    where
        T: Into<Primary> + Send {
        async { unimplemented!("find_optional_from_cache is disabled") }
    }
    fn find_optional_from_cache_with_trashed<T>(conn: &DbConn, id: T) -> impl std::future::Future<Output = Result<Option<Cache>>> + Send
    where
        T: Into<Primary> + Send {
            Self::find_optional_from_cache(conn, id)
    }
    fn find_for_update<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Updater>> + Send
    where
        T: Into<Primary> + Send {
        async { unimplemented!("find_for_update is disabled") }
    }
    fn find_for_update_with_trashed<T>(conn: &mut DbConn, id: T, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Updater>> + Send
    where
        T: Into<Primary> + Send {
            Self::find_for_update(conn, id, filter)
    }
    fn find_many_for_update<I, T>(conn: &mut DbConn, ids: I, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Vec<Updater>>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        async { unimplemented!("find_many_for_update is disabled") }
    }
    fn find_many_for_update_with_trashed<I, T>(conn: &mut DbConn, ids: I, filter: Option<Filter_>) -> impl std::future::Future<Output = Result<Vec<Updater>>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        Self::find_many_for_update(conn, ids, filter)
    }
    fn insert_dummy_cache(conn: &DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { Ok(()) }
    }
    fn save(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<Option<Model>>> + Send;
    fn replace(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<Option<Model>>> + Send;
    fn update_many<I, T>(conn: &mut DbConn, ids: I, updater: Updater) -> impl std::future::Future<Output = Result<u64>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        async { unimplemented!("update_many is disabled") }
    }
    fn insert_ignore(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<Option<Updater>>> + Send;
    fn insert_delayed(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("insert_delayed is disabled") }
    }
    fn save_delayed(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("save_delayed is disabled") }
    }
    fn update_delayed(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("update_delayed is disabled") }
    }
    fn upsert_delayed(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("upsert_delayed is disabled") }
    }
    fn bulk_insert(conn: &mut DbConn, list: Vec<Updater>, ignore: bool) -> impl std::future::Future<Output = Result<()>> + Send;
    fn bulk_replace(conn: &mut DbConn, list: Vec<Updater>) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("bulk_replace is disabled") }
    }
    fn bulk_overwrite(conn: &mut DbConn, list: Vec<Updater>) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("bulk_overwrite is disabled") }
    }
    fn bulk_upsert(conn: &mut DbConn, list: Vec<Updater>, updater: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("bulk_upsert is disabled") }
    }
    fn delete_by_ids<I, T>(conn: &mut DbConn, ids: I) -> impl std::future::Future<Output = Result<u64>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        async { unimplemented!("delete_by_ids is disabled") }
    }
    fn force_delete_by_ids<I, T>(conn: &mut DbConn, ids: I) -> impl std::future::Future<Output = Result<u64>> + Send
    where
        I: IntoIterator<Item = T> + Send,
        T: Into<Primary> {
        async { unimplemented!("force_delete_by_ids is disabled") }
    }
    fn delete(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("delete is disabled") }
    }
    fn restore(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<Model>> + Send {
        async { unimplemented!("restore is disabled") }
    }
    fn force_delete(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("force_delete is disabled") }
    }
    fn force_delete_relations(conn: &mut DbConn, obj: Updater) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("resforce_delete_relationstore is disabled") }
    }
    fn force_delete_all(conn: &mut DbConn) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("force_delete_all is disabled") }
    }
    fn truncate(conn: &mut DbConn) -> impl std::future::Future<Output = Result<()>> + Send {
        async { unimplemented!("truncate is disabled") }
    }
}
@{-"\n"}@