// This code is automatically generated by Senax and is always overwritten.
// Senax v@{ ""|senax_version }@

use crate::connection::{DbConn, DbType};
use ::anyhow::Result;
use ::futures::TryStreamExt;
use ::senax_common::ShardId;
use ::std::collections::BTreeMap;
use ::std::path::Path;
use ::std::sync::Arc;
use ::tokio::sync::{Mutex, Semaphore};

pub use crate::_base::models::USE_FAST_CACHE;
pub use crate::_base::models::CACHE_UPDATE_LOCK;
// pub const USE_FAST_CACHE: bool = @{ config.use_fast_cache() }@;
// pub const USE_STORAGE_CACHE: bool = @{ config.use_storage_cache }@;
// pub static CACHE_UPDATE_LOCK: RwLock<()> = RwLock::const_new(());
@{-"\n"}@
@%- for (name, (_, defs)) in groups %@
pub use crate::_base::models::@{ name|snake|to_var_name }@;
@%- endfor %@

pub use crate::_base::models::NotifyOp;
pub use crate::_base::models::TableName;
pub use crate::_base::models::Controller;
pub use crate::_base::models::ModelTr;

pub(crate) async fn start(db_dir: &Path) -> Result<()> {
@%- for (name, (_, defs)) in groups %@
    if let Some(g) = @{ name|upper }@_CTRL.get() {
        g.start(db_dir).await?;
    }
@%- endfor %@
    Ok(())
}

pub(crate) async fn start_test() -> Result<()> {
@%- for (name, (_, defs)) in groups %@
    if let Some(g) = @{ name|upper }@_CTRL.get() {
        g.start_test().await?;
    }
@%- endfor %@
    Ok(())
}

#[rustfmt::skip]
pub(crate) async fn check() -> Result<()> {
    for shard_id in DbConn::shard_num_range() {
        @%- for (name, (_, defs)) in groups %@
        if let Some(g) = @{ name|upper }@_CTRL.get() {
            g.check(shard_id).await?;
        }
        @%- endfor %@
    }
    Ok(())
}

pub(crate) use crate::_base::models::_clear_cache;

pub(crate) async fn exec_ddl<'c, E>(sql: &str, conn: E) -> Result<()>
where
    E: sqlx::Executor<'c, Database = DbType>,
{
    let mut s = conn.execute_many(sql);
    while s.try_next().await?.is_some() {}
    Ok(())
}

pub(crate) async fn exec_migrate(shard_id: ShardId, ignore_missing: bool) -> Result<()> {
    static MIGRATE_LOCK: Mutex<BTreeMap<String, Arc<Semaphore>>> =
        Mutex::const_new(BTreeMap::new());
    let _lock = {
        let mut lock = MIGRATE_LOCK.lock().await;
        lock.entry(DbConn::get_host_name(shard_id).await?)
            .or_insert_with(|| Arc::new(Semaphore::new(1)))
            .clone()
            .acquire_owned()
            .await?
    };
    let conn = DbConn::_new(shard_id);
    let mut writer = conn.acquire_writer().await?;
    @%- if config.collation.is_some() %@
    exec_ddl(
        r#"ALTER DATABASE COLLATE @{ config.collation.as_ref().unwrap() }@;"#,
        writer.as_mut(),
    )
    .await?;
    @%- endif %@
    exec_ddl(
        r#"
            CREATE TABLE IF NOT EXISTS _sqlx_migrations (
                version BIGINT PRIMARY KEY,
                description TEXT NOT NULL,
                installed_on DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                success BOOLEAN NOT NULL,
                checksum BLOB NOT NULL,
                execution_time BIGINT NOT NULL
            );
        "#,
        writer.as_mut(),
    )
    .await?;
    @%- if config.use_sequence || !config.force_disable_cache %@
    exec_ddl(
        r#"
            CREATE TABLE IF NOT EXISTS "_sequence" (
                "id" INT UNSIGNED NOT NULL PRIMARY KEY,
                "seq" BIGINT UNSIGNED NOT NULL
            );
            INSERT IGNORE INTO "_sequence" VALUES (1, 0);
            INSERT IGNORE INTO "_sequence" VALUES (2, 0);
        "#,
        writer.as_mut(),
    )
    .await?;
    @%- endif %@
    sqlx::migrate!()
        .set_ignore_missing(ignore_missing)
        .run(writer.as_mut())
        .await?;
    Ok(())
}
@% for (name, (_, defs)) in groups %@
pub(crate) use crate::_base::models::@{ name|upper }@_CTRL;
pub fn set_@{ name|snake }@(tr: Box<dyn Controller + Send + Sync>) {
    let _ = @{ name|upper }@_CTRL.set(tr);
}
@%- endfor %@
@{-"\n"}@